<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>P3P</title>

  <!-- PeerJS (signaling for WebRTC). Note: this uses PeerJS's cloud signaling by default. -->
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <style>
    :root{
      --bg: #050608;
      --panel: rgba(14, 16, 20, 0.55);
      --panel2: rgba(14, 16, 20, 0.35);
      --stroke: rgba(255,255,255,0.10);
      --stroke2: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.62);
      --muted2: rgba(255,255,255,0.45);
      --accent: #2f6df6;
      --accent2: #1f4fd8;
      --danger: #ff4d4d;
      --ok: #39d98a;
      --shadow: 0 18px 60px rgba(0,0,0,0.55);
      --radius: 18px;
      --radius2: 24px;
    }

    /* Apple-like system font stack (real SF on macOS, great fallbacks elsewhere) */
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont,
        "SF Pro Display", "SF Pro Text", "Helvetica Neue",
        Helvetica, Arial, system-ui, sans-serif;
      overflow: hidden;
    }

    /* Three.js canvas */
    #bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    /* cinematic overlay (doesn't kill Mars visibility) */
    .overlay {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      background:
        radial-gradient(1200px 700px at 50% 30%, rgba(0,0,0,0.15), rgba(0,0,0,0.78) 70%),
        linear-gradient(to bottom, rgba(0,0,0,0.55), rgba(0,0,0,0.72));
    }

    /* Layout shell */
    .app {
      position: fixed;
      inset: 0;
      z-index: 2;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      position: sticky;
      top: 0;
      z-index: 5;
      padding: 20px 20px 14px 20px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 16px;
      align-items: start;
      backdrop-filter: blur(18px);
      background: rgba(0,0,0,0.25);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }
    .brand-top {
      display: flex;
      align-items: baseline;
      gap: 10px;
      white-space: nowrap;
    }
    .brand h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: -0.6px;
      font-weight: 650;
    }
    .pill {
      font-size: 12px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
    }
    .pill.ok { color: rgba(57,217,138,0.95); border-color: rgba(57,217,138,0.22); background: rgba(57,217,138,0.08); }
    .pill.bad { color: rgba(255,255,255,0.6); }

    .subline {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      color: var(--muted);
      font-size: 13px;
    }
    .users {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      min-width: 0;
      flex-wrap: wrap;
    }
    .userTag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      color: rgba(255,255,255,0.78);
      font-size: 12px;
      transition: transform .18s ease, background .18s ease, border-color .18s ease;
    }
    .userTag:hover { transform: translateY(-1px); background: rgba(255,255,255,0.07); border-color: rgba(255,255,255,0.14); }
    .crown { font-size: 12px; opacity: 0.95; }

    /* Corner controls (aligned and contained) */
    .corner {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
      min-width: 260px;
    }

    .card {
      width: 260px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.10);
      background: var(--panel);
      backdrop-filter: blur(18px);
      box-shadow: var(--shadow);
      overflow: hidden; /* prevents any clipping outside header area */
    }

    .card .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .card .row:last-child { border-bottom: none; }

    .label {
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .value {
      font-size: 12px;
      color: rgba(255,255,255,0.82);
      max-width: 170px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: right;
    }

    .btnRow {
      display: flex;
      gap: 8px;
      padding: 10px 12px;
      background: rgba(0,0,0,0.12);
    }

    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.88);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: transform .18s ease, background .18s ease, border-color .18s ease, box-shadow .18s ease;
      box-shadow: 0 10px 25px rgba(0,0,0,0.25);
    }
    button:hover {
      transform: translateY(-1px);
      background: rgba(255,255,255,0.09);
      border-color: rgba(255,255,255,0.14);
      box-shadow: 0 16px 35px rgba(0,0,0,0.35);
    }
    button:active { transform: translateY(0px) scale(0.99); }

    .primary {
      background: linear-gradient(180deg, rgba(47,109,246,0.95), rgba(31,79,216,0.95));
      border-color: rgba(47,109,246,0.35);
    }
    .primary:hover { background: linear-gradient(180deg, rgba(47,109,246,1), rgba(31,79,216,1)); }

    .danger {
      background: rgba(255,77,77,0.10);
      border-color: rgba(255,77,77,0.22);
      color: rgba(255,200,200,0.95);
    }

    .ghost { background: rgba(255,255,255,0.04); }

    /* Chat area */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #chat {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      padding: 18px 18px 10px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .bubble {
      max-width: min(720px, 78%);
      padding: 12px 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.06);
      backdrop-filter: blur(14px);
      animation: in .22s ease both;
      box-shadow: 0 14px 45px rgba(0,0,0,0.28);
      word-wrap: break-word;
      white-space: pre-wrap;
    }
    .bubble.you {
      align-self: flex-end;
      background: linear-gradient(180deg, rgba(47,109,246,0.92), rgba(31,79,216,0.92));
      border-color: rgba(47,109,246,0.28);
    }
    .bubble.sys {
      align-self: center;
      max-width: 820px;
      background: rgba(255,255,255,0.04);
      border-color: rgba(255,255,255,0.08);
      color: var(--muted);
      font-size: 13px;
    }
    .meta {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
      font-size: 12px;
      color: rgba(255,255,255,0.75);
    }
    .meta .who { font-weight: 650; letter-spacing: -0.2px; }
    .meta .time { color: rgba(255,255,255,0.45); }

    @keyframes in {
      from { opacity: 0; transform: translateY(8px) scale(0.99); }
      to   { opacity: 1; transform: translateY(0) scale(1); }
    }

    .typing {
      height: 20px;
      padding: 0 18px 10px 18px;
      color: var(--muted2);
      font-size: 12px;
    }

    /* Input bar */
    .inputBar {
      padding: 12px 14px 16px 14px;
      border-top: 1px solid rgba(255,255,255,0.06);
      backdrop-filter: blur(18px);
      background: rgba(0,0,0,0.28);
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }

    textarea {
      flex: 1;
      min-height: 44px;
      max-height: 140px;
      resize: none;
      border-radius: 18px;
      padding: 12px 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
      outline: none;
      font-size: 14px;
      line-height: 1.35;
      transition: background .18s ease, border-color .18s ease, transform .18s ease;
    }
    textarea:focus {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.14);
    }

    /* Modal */
    .modalBack {
      position: fixed;
      inset: 0;
      z-index: 10;
      background: rgba(0,0,0,0.62);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    .modal {
      width: min(560px, 100%);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(12, 14, 18, 0.72);
      backdrop-filter: blur(24px);
      box-shadow: var(--shadow);
      overflow: hidden;
      transform: translateY(6px);
      animation: pop .22s ease both;
    }
    @keyframes pop {
      from { opacity: 0; transform: translateY(12px) scale(0.985); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .modalHead{
      padding: 16px 18px 12px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .modalTitle{
      display:flex; flex-direction:column; gap:4px;
    }
    .modalTitle strong{ font-size: 16px; letter-spacing: -0.3px; }
    .modalTitle span{ font-size: 12px; color: var(--muted); }
    .modalBody { padding: 14px 18px 18px 18px; display: grid; gap: 12px; }
    .field {
      display: grid;
      gap: 6px;
    }
    .field label { font-size: 12px; color: var(--muted); }
    .field input {
      height: 44px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
      padding: 0 12px;
      outline: none;
      font-size: 14px;
    }
    .seg {
      display:flex;
      gap: 8px;
      padding: 6px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
    }
    .seg button {
      flex:1;
      box-shadow: none;
      border: 1px solid transparent;
      background: transparent;
      padding: 10px 10px;
      border-radius: 12px;
      font-weight: 650;
      color: rgba(255,255,255,0.76);
    }
    .seg button.active {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.92);
    }
    .modalFoot{
      padding: 14px 18px;
      border-top: 1px solid rgba(255,255,255,0.06);
      display:flex;
      gap: 10px;
      justify-content: flex-end;
      background: rgba(0,0,0,0.10);
    }
    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }

    @media (max-width: 860px){
      header { grid-template-columns: 1fr; }
      .corner { align-items: stretch; }
      .card { width: 100%; }
    }
  </style>
</head>

<body>
  <canvas id="bg"></canvas>
  <div class="overlay"></div>

  <div class="app">
    <header>
      <div class="brand">
        <div class="brand-top">
          <h1>P3P</h1>
          <span id="statusPill" class="pill bad">Offline</span>
          <span id="rolePill" class="pill">Guest</span>
        </div>

        <div class="subline">
          <span id="roomLabel">Room: â€”</span>
          <span>â€¢</span>
          <span id="youLabel">You: â€”</span>
          <span>â€¢</span>
          <span class="users" id="usersLine"></span>
        </div>
      </div>

      <div class="corner">
        <div class="card">
          <div class="row">
            <div class="label">Your ID</div>
            <div class="value" id="myId">â€”</div>
          </div>
          <div class="row">
            <div class="label">Room ID</div>
            <div class="value" id="roomId">â€”</div>
          </div>
          <div class="btnRow">
            <button class="ghost" id="copyMyIdBtn">Copy</button>
            <button class="ghost" id="openJoinBtn">Join / Create</button>
            <button class="danger" id="leaveBtn">Leave</button>
          </div>
        </div>

        <div class="card">
          <div class="row">
            <div class="label">Admin Commands</div>
            <div class="value">/kick name</div>
          </div>
          <div class="row">
            <div class="label">Tip</div>
            <div class="value">Shift+Enter = newline</div>
          </div>
        </div>
      </div>
    </header>

    <div class="main">
      <div id="chat"></div>
      <div class="typing" id="typing"></div>

      <div class="inputBar">
        <textarea id="msg" placeholder="Messageâ€¦ (Enter to send)"></textarea>
        <button class="primary" id="sendBtn">Send</button>
      </div>
    </div>
  </div>

  <!-- Modern modal (no browser prompt) -->
  <div class="modalBack" id="modalBack">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalHead">
        <div class="modalTitle">
          <strong>Join / Create Room</strong>
          <span>Private P2P room. Host = admin. Others join using Room ID.</span>
        </div>
        <button class="ghost" id="closeModal">Close</button>
      </div>

      <div class="modalBody">
        <div class="field">
          <label>Display name</label>
          <input id="nameInput" placeholder="e.g., Kashif" maxlength="24" />
        </div>

        <div class="field">
          <label>Mode</label>
          <div class="seg">
            <button id="modeCreate" class="active" type="button">Create (Admin)</button>
            <button id="modeJoin" type="button">Join</button>
          </div>
          <div class="hint">If you create, share your Room ID with friends. If you join, paste the Room ID.</div>
        </div>

        <div class="field" id="joinField" style="display:none;">
          <label>Room ID to join</label>
          <input id="roomInput" placeholder="Paste Room IDâ€¦" />
        </div>

        <div class="hint">
          Multi-user is handled by the host (admin) who relays messages and maintains the user list.
          If the host leaves, the room ends.
        </div>
      </div>

      <div class="modalFoot">
        <button class="primary" id="goBtn">Continue</button>
      </div>
    </div>
  </div>

  <script>
    /*********************
     * 3D BACKGROUND
     *********************/
    const canvas = document.getElementById('bg');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.25;
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(0, 0, 14);

    // Lights (fixes "black Mars")
    const amb = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(amb);

    const dir = new THREE.DirectionalLight(0xffffff, 1.6);
    dir.position.set(8, 4, 10);
    scene.add(dir);

    const rim = new THREE.DirectionalLight(0xffc9a8, 0.65);
    rim.position.set(-10, -3, -6);
    scene.add(rim);

    // Starfield
    function makeStars(count = 1200) {
      const geom = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      for (let i=0; i<count; i++){
        const r = 450 * Math.random() + 50;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2*Math.random() - 1);
        pos[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
        pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        pos[i*3+2] = r * Math.cos(phi);
      }
      geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      const mat = new THREE.PointsMaterial({ size: 1.2, sizeAttenuation: true, transparent: true, opacity: 0.55 });
      const pts = new THREE.Points(geom, mat);
      return pts;
    }
    scene.add(makeStars());

    // Mars sphere
    const mars = new THREE.Mesh(
      new THREE.SphereGeometry(5.1, 96, 96),
      new THREE.MeshStandardMaterial({
        roughness: 0.95,
        metalness: 0.0
      })
    );
    scene.add(mars);

    // Texture (CORS-safe source typically works)
    const texLoader = new THREE.TextureLoader();
    const marsTexUrl = "https://threejsfundamentals.org/threejs/resources/images/mars_1k_color.jpg";
    texLoader.load(
      marsTexUrl,
      (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        mars.material.map = tex;
        mars.material.needsUpdate = true;
      },
      undefined,
      () => {
        // If texture fails, keep a nice fallback
        mars.material.color = new THREE.Color(0x7a3b24);
      }
    );

    // Authentic-ish rotation: Mars sidereal day ~24.6h. We scale for visuals.
    let lastT = performance.now();
    let spinSpeed = (Math.PI * 2) / 60; // 1 rotation / 60s (looks "authentic" on-screen)

    // subtle camera parallax
    let targetX = 0, targetY = 0;
    window.addEventListener('mousemove', (e) => {
      const nx = (e.clientX / window.innerWidth) * 2 - 1;
      const ny = (e.clientY / window.innerHeight) * 2 - 1;
      targetX = nx * 0.45;
      targetY = ny * 0.25;
    }, { passive: true });

    function animate(t){
      const dt = Math.min((t - lastT) / 1000, 0.05);
      lastT = t;

      mars.rotation.y += spinSpeed * dt;
      mars.rotation.x = 0.06; // axial tilt vibe

      camera.position.x += (targetX - camera.position.x) * 0.04;
      camera.position.y += (-targetY - camera.position.y) * 0.04;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    /*********************
     * P3P MULTI-USER P2P (Host star topology)
     *********************/
    const ui = {
      chat: document.getElementById('chat'),
      typing: document.getElementById('typing'),
      msg: document.getElementById('msg'),
      sendBtn: document.getElementById('sendBtn'),
      statusPill: document.getElementById('statusPill'),
      rolePill: document.getElementById('rolePill'),
      roomLabel: document.getElementById('roomLabel'),
      youLabel: document.getElementById('youLabel'),
      usersLine: document.getElementById('usersLine'),
      myId: document.getElementById('myId'),
      roomId: document.getElementById('roomId'),
      copyMyIdBtn: document.getElementById('copyMyIdBtn'),
      openJoinBtn: document.getElementById('openJoinBtn'),
      leaveBtn: document.getElementById('leaveBtn'),

      modalBack: document.getElementById('modalBack'),
      closeModal: document.getElementById('closeModal'),
      goBtn: document.getElementById('goBtn'),
      nameInput: document.getElementById('nameInput'),
      roomInput: document.getElementById('roomInput'),
      joinField: document.getElementById('joinField'),
      modeCreate: document.getElementById('modeCreate'),
      modeJoin: document.getElementById('modeJoin'),
      openModalBtn: document.getElementById('openJoinBtn'),
    };

    const state = {
      peer: null,
      myPeerId: null,
      mode: "create",        // "create" or "join"
      myName: null,
      roomId: null,          // host's peer ID acts as room ID
      isHost: false,
      hostConn: null,        // if joiner, connection to host
      conns: new Map(),      // host only: peerId -> DataConnection
      users: new Map(),      // peerId -> { name, role }
      typingTimers: new Map(),
      connected: false
    };

    function nowTime(){
      const d = new Date();
      return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    }

    function setStatus(online){
      ui.statusPill.textContent = online ? "Online" : "Offline";
      ui.statusPill.classList.toggle("ok", online);
      ui.statusPill.classList.toggle("bad", !online);
    }

    function setRole(role){
      ui.rolePill.textContent = role;
    }

    function setRoomLabel(id){
      ui.roomLabel.textContent = `Room: ${id ? id : "â€”"}`;
      ui.roomId.textContent = id ? id : "â€”";
    }

    function setYouLabel(name){
      ui.youLabel.textContent = `You: ${name ? name : "â€”"}`;
    }

    function addSystem(text){
      const el = document.createElement('div');
      el.className = "bubble sys";
      el.textContent = text;
      ui.chat.appendChild(el);
      ui.chat.scrollTop = ui.chat.scrollHeight;
    }

    function addBubble({ who, text, mine=false }){
      const wrap = document.createElement('div');
      wrap.className = "bubble" + (mine ? " you" : "");

      const meta = document.createElement('div');
      meta.className = "meta";
      meta.innerHTML = `<div class="who">${escapeHtml(who)}</div><div class="time">${nowTime()}</div>`;

      const body = document.createElement('div');
      body.textContent = text;

      wrap.appendChild(meta);
      wrap.appendChild(body);

      ui.chat.appendChild(wrap);
      ui.chat.scrollTop = ui.chat.scrollHeight;
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }

    function renderUsers(){
      ui.usersLine.innerHTML = "";
      const entries = Array.from(state.users.entries())
        .map(([pid, u]) => ({ pid, ...u }))
        .sort((a,b) => (a.role === "admin" ? -1 : 1) - (b.role === "admin" ? -1 : 1) || a.name.localeCompare(b.name));

      if (!entries.length){
        const span = document.createElement('span');
        span.textContent = "Connected: â€”";
        ui.usersLine.appendChild(span);
        return;
      }

      const label = document.createElement('span');
      label.textContent = "Connected:";
      ui.usersLine.appendChild(label);

      for (const u of entries){
        const tag = document.createElement('span');
        tag.className = "userTag";
        tag.title = u.pid;
        tag.innerHTML = `${u.role === "admin" ? '<span class="crown">ðŸ‘‘</span>' : ''}${escapeHtml(u.name)}`;
        ui.usersLine.appendChild(tag);
      }
    }

    function showTyping(name){
      ui.typing.textContent = `${name} is typingâ€¦`;
      clearTimeout(state._typingUiTimer);
      state._typingUiTimer = setTimeout(() => ui.typing.textContent = "", 1100);
    }

    function openModal(){
      ui.modalBack.style.display = "flex";
      // defaults
      ui.nameInput.value = state.myName || "";
      if (state.mode === "join"){
        ui.modeJoin.classList.add("active");
        ui.modeCreate.classList.remove("active");
        ui.joinField.style.display = "grid";
      } else {
        ui.modeCreate.classList.add("active");
        ui.modeJoin.classList.remove("active");
        ui.joinField.style.display = "none";
      }
      setTimeout(() => ui.nameInput.focus(), 50);
    }

    function closeModal(){
      ui.modalBack.style.display = "none";
    }

    ui.modeCreate.addEventListener('click', () => {
      state.mode = "create";
      ui.modeCreate.classList.add("active");
      ui.modeJoin.classList.remove("active");
      ui.joinField.style.display = "none";
    });

    ui.modeJoin.addEventListener('click', () => {
      state.mode = "join";
      ui.modeJoin.classList.add("active");
      ui.modeCreate.classList.remove("active");
      ui.joinField.style.display = "grid";
      ui.roomInput.focus();
    });

    ui.openJoinBtn.addEventListener('click', openModal);
    ui.closeModal.addEventListener('click', closeModal);
    ui.modalBack.addEventListener('click', (e) => { if (e.target === ui.modalBack) closeModal(); });

    ui.copyMyIdBtn.addEventListener('click', async () => {
      if (!state.myPeerId) return;
      try {
        await navigator.clipboard.writeText(state.myPeerId);
        addSystem("Copied your ID to clipboard.");
      } catch {
        addSystem("Could not copy automatically. Select and copy your ID manually.");
      }
    });

    ui.leaveBtn.addEventListener('click', () => {
      leaveRoom("You left the room.");
    });

    function initPeer(){
      if (state.peer) return;

      // Create peer
      state.peer = new Peer();
      setStatus(false);

      state.peer.on('open', (id) => {
        state.myPeerId = id;
        ui.myId.textContent = id;
        addSystem("Ready. Create a room or join one.");
      });

      // If someone connects to you, you're the host (or you became host)
      state.peer.on('connection', (conn) => {
        // If user is in join mode and someone connects unexpectedly, ignore unless we are host.
        if (!state.isHost){
          // If we created a room, we ARE host even if not flagged yet.
          // We'll only accept inbound if we are in create mode or already hosting.
          if (state.mode !== "create") {
            conn.close();
            return;
          }
        }

        state.isHost = true;
        setRole("Admin");
        state.roomId = state.myPeerId;
        setRoomLabel(state.roomId);
        setStatus(true);

        attachHostConn(conn);
      });

      state.peer.on('error', (err) => {
        addSystem("Peer error: " + (err?.type || err?.message || String(err)));
      });
    }

    function attachHostConn(conn){
      // Host side: new participant connection
      conn.on('open', () => {
        // Wait for hello packet with name
      });

      conn.on('data', (msg) => {
        handleHostIncoming(conn, msg);
      });

      conn.on('close', () => {
        if (state.conns.has(conn.peer)) {
          const u = state.users.get(conn.peer);
          state.conns.delete(conn.peer);
          state.users.delete(conn.peer);
          broadcastRoster();
          if (u) addSystem(`${u.name} disconnected.`);
        }
      });
    }

    function hostAddUser(peerId, name){
      // ensure unique display name
      const existingNames = new Set(Array.from(state.users.values()).map(u => u.name.toLowerCase()));
      let finalName = (name || "Guest").trim().slice(0,24) || "Guest";
      let base = finalName;
      let n = 2;
      while (existingNames.has(finalName.toLowerCase())){
        finalName = `${base} ${n++}`;
      }

      state.users.set(peerId, { name: finalName, role: "member" });
      renderUsers();
      return finalName;
    }

    function broadcastToAll(payload, exceptPeerId=null){
      for (const [pid, c] of state.conns.entries()){
        if (exceptPeerId && pid === exceptPeerId) continue;
        if (c.open) c.send(payload);
      }
    }

    function broadcastRoster(){
      renderUsers();
      const roster = Array.from(state.users.entries()).map(([pid, u]) => ({ pid, name: u.name, role: u.role }));
      // host itself as admin
      roster.unshift({ pid: state.myPeerId, name: state.myName || "Admin", role: "admin" });
      broadcastToAll({ t:"roster", roster });
      // also update host UI
      const hostMap = new Map();
      hostMap.set(state.myPeerId, { name: state.myName || "Admin", role:"admin" });
      for (const [pid,u] of state.users.entries()) hostMap.set(pid, u);
      state.users = hostMap;
      renderUsers();
    }

    function handleHostIncoming(conn, msg){
      if (!msg || typeof msg !== "object") return;

      if (msg.t === "hello"){
        // register connection
        state.conns.set(conn.peer, conn);
        const assigned = hostAddUser(conn.peer, msg.name);
        addSystem(`${assigned} joined.`);
        // respond with ack + assigned name
        conn.send({ t:"hello_ack", assignedName: assigned, roomId: state.roomId, hostId: state.myPeerId });
        broadcastRoster();
        return;
      }

      if (msg.t === "chat"){
        // relay to everyone (including host display)
        const fromUser = state.users.get(conn.peer)?.name || "Guest";
        // show on host UI:
        addBubble({ who: fromUser, text: msg.text, mine:false });
        // relay to everyone except sender
        broadcastToAll({ t:"chat", from: fromUser, text: msg.text }, conn.peer);
        return;
      }

      if (msg.t === "typing"){
        const fromUser = state.users.get(conn.peer)?.name || "Someone";
        // broadcast typing to others except sender
        broadcastToAll({ t:"typing", from: fromUser }, conn.peer);
        return;
      }

      if (msg.t === "req_kick"){
        // ignore: only host kicks
        return;
      }
    }

    function joinRoom(roomId, name){
      state.isHost = false;
      setRole("Guest");
      state.roomId = roomId;
      setRoomLabel(roomId);
      setYouLabel(name);
      setStatus(false);

      const hostConn = state.peer.connect(roomId, { reliable: true });
      state.hostConn = hostConn;

      hostConn.on('open', () => {
        // introduce yourself
        hostConn.send({ t:"hello", name });
      });

      hostConn.on('data', (msg) => {
        handleClientIncoming(msg);
      });

      hostConn.on('close', () => {
        setStatus(false);
        addSystem("Disconnected from host.");
        state.connected = false;
        // clear users list except self
        state.users = new Map([[state.myPeerId, { name: state.myName, role: "me" }]]);
        renderUsers();
      });

      hostConn.on('error', (err) => {
        addSystem("Connection error: " + (err?.message || String(err)));
      });
    }

    function handleClientIncoming(msg){
      if (!msg || typeof msg !== "object") return;

      if (msg.t === "hello_ack"){
        state.myName = msg.assignedName || state.myName;
        setYouLabel(state.myName);
        setStatus(true);
        state.connected = true;
        addSystem(`Connected to room.`);
        return;
      }

      if (msg.t === "roster"){
        // roster includes host + members
        const m = new Map();
        for (const u of msg.roster || []){
          m.set(u.pid, { name: u.name, role: u.role });
        }
        state.users = m;
        renderUsers();
        return;
      }

      if (msg.t === "chat"){
        addBubble({ who: msg.from || "Friend", text: msg.text || "", mine:false });
        return;
      }

      if (msg.t === "typing"){
        showTyping(msg.from || "Someone");
        return;
      }

      if (msg.t === "kicked"){
        addSystem("You were kicked by the admin.");
        leaveRoom("Kicked.");
        return;
      }
    }

    function leaveRoom(note){
      // close conns
      try {
        if (state.hostConn) state.hostConn.close();
      } catch {}
      try {
        for (const c of state.conns.values()) c.close();
      } catch {}

      state.conns.clear();
      state.users.clear();
      state.hostConn = null;
      state.isHost = false;
      state.roomId = null;
      state.connected = false;

      setRoomLabel(null);
      setStatus(false);
      setRole("Guest");
      renderUsers();

      if (note) addSystem(note);
    }

    function hostKickByName(name){
      if (!state.isHost) return false;
      const target = name.trim().toLowerCase();
      if (!target) return false;

      // find peerId by name
      let victimPeerId = null;
      for (const [pid, u] of state.users.entries()){
        if ((u.name || "").toLowerCase() === target){
          victimPeerId = pid;
          break;
        }
      }
      if (!victimPeerId) return false;

      const conn = state.conns.get(victimPeerId);
      if (conn && conn.open){
        conn.send({ t:"kicked" });
        conn.close();
      }
      state.conns.delete(victimPeerId);
      const victimName = state.users.get(victimPeerId)?.name || name;
      state.users.delete(victimPeerId);
      broadcastRoster();
      addSystem(`Kicked ${victimName}.`);
      return true;
    }

    function sendChat(text){
      const trimmed = text.trim();
      if (!trimmed) return;

      // admin commands
      if (trimmed.startsWith("/")){
        if (!state.isHost){
          addSystem("Only the admin can run commands.");
          return;
        }
        const [cmd, ...rest] = trimmed.slice(1).split(" ");
        if (cmd.toLowerCase() === "kick"){
          const victim = rest.join(" ").trim();
          if (!victim) { addSystem("Usage: /kick username"); return; }
          if (!hostKickByName(victim)) addSystem(`User not found: ${victim}`);
          return;
        }
        addSystem(`Unknown command: /${cmd}`);
        return;
      }

      // host sends locally + broadcasts to everyone
      if (state.isHost){
        addBubble({ who: state.myName || "Admin", text: trimmed, mine:true });
        broadcastToAll({ t:"chat", from: state.myName || "Admin", text: trimmed });
        return;
      }

      // client -> host
      if (state.hostConn && state.hostConn.open){
        state.hostConn.send({ t:"chat", text: trimmed });
        addBubble({ who: state.myName || "You", text: trimmed, mine:true });
      } else {
        addSystem("Not connected.");
      }
    }

    // typing signals
    let typingCooldown = 0;
    function sendTyping(){
      const now = Date.now();
      if (now < typingCooldown) return;
      typingCooldown = now + 450;

      if (state.isHost) return; // host typing indicator isn't necessary here
      if (state.hostConn && state.hostConn.open){
        state.hostConn.send({ t:"typing" });
      }
    }

    // input behaviors
    ui.sendBtn.addEventListener('click', () => {
      sendChat(ui.msg.value);
      ui.msg.value = "";
      ui.msg.style.height = "auto";
    });

    ui.msg.addEventListener('input', () => {
      sendTyping();
      ui.msg.style.height = "auto";
      ui.msg.style.height = Math.min(ui.msg.scrollHeight, 140) + "px";
    });

    ui.msg.addEventListener('keydown', (e) => {
      if (e.key === "Enter" && !e.shiftKey){
        e.preventDefault();
        ui.sendBtn.click();
      }
    });

    // Modal continue
    ui.goBtn.addEventListener('click', () => {
      const name = (ui.nameInput.value || "").trim().slice(0,24);
      if (!name) { addSystem("Enter a display name first."); ui.nameInput.focus(); return; }

      initPeer();
      state.myName = name;
      setYouLabel(name);

      if (state.mode === "create"){
        // host room id is your peer id
        // we don't "connect" to yourself; you just wait for others
        state.isHost = true;
        setRole("Admin");
        setStatus(true);
        state.roomId = state.myPeerId || "(loadingâ€¦)";
        setRoomLabel(state.roomId);

        // host users list includes you
        state.users = new Map();
        state.users.set(state.myPeerId, { name: state.myName, role: "admin" });
        renderUsers();

        addSystem("Room created. Share your Room ID (top-right) with friends.");
        closeModal();

        // If peerId not ready yet, update when open arrives
        const fixRoomId = setInterval(() => {
          if (state.myPeerId){
            state.roomId = state.myPeerId;
            setRoomLabel(state.roomId);
            // ensure host user record
            state.users.set(state.myPeerId, { name: state.myName, role: "admin" });
            renderUsers();
            clearInterval(fixRoomId);
          }
        }, 100);

        return;
      }

      // join
      const rid = (ui.roomInput.value || "").trim();
      if (!rid) { addSystem("Paste a Room ID to join."); ui.roomInput.focus(); return; }

      closeModal();
      addSystem("Connecting to roomâ€¦");
      joinRoom(rid, name);
    });

    // bootstrap
    initPeer();
    openModal(); // open on first load

    setInterval(() => {
      // keep room id current for host after peer open
      if (state.isHost && state.myPeerId) {
        ui.roomId.textContent = state.myPeerId;
        ui.myId.textContent = state.myPeerId;
        if (!state.roomId || state.roomId === "(loadingâ€¦)") {
          state.roomId = state.myPeerId;
          setRoomLabel(state.roomId);
        }
      }
    }, 500);
  </script>
</body>
</html>
